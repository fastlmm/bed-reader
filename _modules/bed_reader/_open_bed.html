

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>bed_reader._open_bed &mdash; Bed Reader 1.0.6 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=e2a723ec"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Bed Reader
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../cloud_urls.html">Cloud URL Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../cloud_urls.html#http-section">Http</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../cloud_urls.html#local-file-section">Local File</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../cloud_urls.html#local-file-url">Local File URL</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../cloud_urls.html#aws-section">AWS S3</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Bed Reader</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content style-external-links">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">bed_reader._open_bed</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for bed_reader._open_bed</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">multiprocessing</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">re</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">io</span><span class="w"> </span><span class="kn">import</span> <span class="n">BytesIO</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">repeat</span><span class="p">,</span> <span class="n">takewhile</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pathlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">TYPE_CHECKING</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">urllib.parse</span><span class="w"> </span><span class="kn">import</span> <span class="n">ParseResult</span> <span class="k">as</span> <span class="n">UrlParseResult</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">urllib.parse</span><span class="w"> </span><span class="kn">import</span> <span class="n">urlparse</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">sparse</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">sparse</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="n">sparse</span> <span class="o">=</span> <span class="kc">None</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.bed_reader</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">check_file_cloud</span><span class="p">,</span>
    <span class="n">read_cloud_f32</span><span class="p">,</span>
    <span class="n">read_cloud_f64</span><span class="p">,</span>
    <span class="n">read_cloud_i8</span><span class="p">,</span>
    <span class="n">read_f32</span><span class="p">,</span>
    <span class="n">read_f64</span><span class="p">,</span>
    <span class="n">read_i8</span><span class="p">,</span>
    <span class="n">url_to_bytes</span><span class="p">,</span>
<span class="p">)</span>


<span class="c1"># https://stackoverflow.com/questions/845058/how-to-get-line-count-of-a-large-file-cheaply-in-python</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_rawincount</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="n">f</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">bufgen</span> <span class="o">=</span> <span class="n">takewhile</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">repeat</span><span class="p">(</span><span class="kc">None</span><span class="p">)))</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">buf</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">buf</span> <span class="ow">in</span> <span class="n">bufgen</span><span class="p">)</span>


<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">_MetaMeta</span><span class="p">:</span>
    <span class="n">suffix</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">column</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="nb">type</span>
    <span class="n">missing_value</span><span class="p">:</span> <span class="nb">object</span>
    <span class="n">fill_sequence</span><span class="p">:</span> <span class="nb">object</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_all_same</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">missing</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">str_</span><span class="p">):</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&lt;U</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">missing</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">missing</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_sequence</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">missing</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">str_</span><span class="p">):</span>
        <span class="n">longest</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">key</span><span class="si">}{</span><span class="n">length</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&lt;U</span><span class="si">{</span><span class="n">longest</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">fromiter</span><span class="p">(</span>
        <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">key</span><span class="si">}{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">length</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">length</span><span class="p">,</span>
    <span class="p">)</span>


<span class="n">_delimiters</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;fam&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;\s+&quot;</span><span class="p">,</span> <span class="s2">&quot;bim&quot;</span><span class="p">:</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">}</span>
<span class="n">_count_name</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;fam&quot;</span><span class="p">:</span> <span class="s2">&quot;iid_count&quot;</span><span class="p">,</span> <span class="s2">&quot;bim&quot;</span><span class="p">:</span> <span class="s2">&quot;sid_count&quot;</span><span class="p">}</span>


<span class="n">_meta_meta</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1"># https://stackoverflow.com/questions/41921255/staticmethod-object-is-not-callable</span>
    <span class="s2">&quot;fid&quot;</span><span class="p">:</span> <span class="n">_MetaMeta</span><span class="p">(</span><span class="s2">&quot;fam&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">str_</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="n">_all_same</span><span class="p">),</span>
    <span class="s2">&quot;iid&quot;</span><span class="p">:</span> <span class="n">_MetaMeta</span><span class="p">(</span><span class="s2">&quot;fam&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">str_</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">_sequence</span><span class="p">),</span>
    <span class="s2">&quot;father&quot;</span><span class="p">:</span> <span class="n">_MetaMeta</span><span class="p">(</span><span class="s2">&quot;fam&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">str_</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="n">_all_same</span><span class="p">),</span>
    <span class="s2">&quot;mother&quot;</span><span class="p">:</span> <span class="n">_MetaMeta</span><span class="p">(</span><span class="s2">&quot;fam&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">str_</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="n">_all_same</span><span class="p">),</span>
    <span class="s2">&quot;sex&quot;</span><span class="p">:</span> <span class="n">_MetaMeta</span><span class="p">(</span><span class="s2">&quot;fam&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">_all_same</span><span class="p">),</span>
    <span class="s2">&quot;pheno&quot;</span><span class="p">:</span> <span class="n">_MetaMeta</span><span class="p">(</span><span class="s2">&quot;fam&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">str_</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="n">_all_same</span><span class="p">),</span>
    <span class="s2">&quot;chromosome&quot;</span><span class="p">:</span> <span class="n">_MetaMeta</span><span class="p">(</span><span class="s2">&quot;bim&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">str_</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="n">_all_same</span><span class="p">),</span>
    <span class="s2">&quot;sid&quot;</span><span class="p">:</span> <span class="n">_MetaMeta</span><span class="p">(</span><span class="s2">&quot;bim&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">str_</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">_sequence</span><span class="p">),</span>
    <span class="s2">&quot;cm_position&quot;</span><span class="p">:</span> <span class="n">_MetaMeta</span><span class="p">(</span><span class="s2">&quot;bim&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">_all_same</span><span class="p">),</span>
    <span class="s2">&quot;bp_position&quot;</span><span class="p">:</span> <span class="n">_MetaMeta</span><span class="p">(</span><span class="s2">&quot;bim&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">_all_same</span><span class="p">),</span>
    <span class="s2">&quot;allele_1&quot;</span><span class="p">:</span> <span class="n">_MetaMeta</span><span class="p">(</span><span class="s2">&quot;bim&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">str_</span><span class="p">,</span> <span class="s2">&quot;A1&quot;</span><span class="p">,</span> <span class="n">_all_same</span><span class="p">),</span>
    <span class="s2">&quot;allele_2&quot;</span><span class="p">:</span> <span class="n">_MetaMeta</span><span class="p">(</span><span class="s2">&quot;bim&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">str_</span><span class="p">,</span> <span class="s2">&quot;A2&quot;</span><span class="p">,</span> <span class="n">_all_same</span><span class="p">),</span>
<span class="p">}</span>


<span class="k">def</span><span class="w"> </span><span class="nf">get_num_threads</span><span class="p">(</span><span class="n">num_threads</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">num_threads</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">num_threads</span>
    <span class="k">if</span> <span class="s2">&quot;PST_NUM_THREADS&quot;</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s2">&quot;PST_NUM_THREADS&quot;</span><span class="p">])</span>
    <span class="k">if</span> <span class="s2">&quot;NUM_THREADS&quot;</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s2">&quot;NUM_THREADS&quot;</span><span class="p">])</span>
    <span class="k">if</span> <span class="s2">&quot;MKL_NUM_THREADS&quot;</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s2">&quot;MKL_NUM_THREADS&quot;</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>


<span class="k">def</span><span class="w"> </span><span class="nf">get_max_concurrent_requests</span><span class="p">(</span><span class="n">max_concurrent_requests</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">max_concurrent_requests</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">max_concurrent_requests</span>
    <span class="k">return</span> <span class="mi">10</span>


<span class="k">def</span><span class="w"> </span><span class="nf">get_max_chunk_bytes</span><span class="p">(</span><span class="n">max_chunk_bytes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">max_chunk_bytes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">max_chunk_bytes</span>
    <span class="k">return</span> <span class="mi">8_000_000</span>


<div class="viewcode-block" id="open_bed">
<a class="viewcode-back" href="../../index.html#bed_reader.open_bed">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">open_bed</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Open a PLINK .bed file, local or cloud, for reading.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    location: pathlib.Path or str</span>
<span class="sd">        File path or URL to the .bed file. See :doc:`cloud_urls` for details on cloud URLs.</span>
<span class="sd">    iid_count: None or int, optional</span>
<span class="sd">        Number of individuals (samples) in the .bed file.</span>
<span class="sd">        The default (``iid_count=None``) finds the number</span>
<span class="sd">        automatically by quickly scanning the .fam file.</span>
<span class="sd">    sid_count: None or int, optional</span>
<span class="sd">        Number of SNPs (variants) in the .bed file.</span>
<span class="sd">        The default (``sid_count=None``) finds the number</span>
<span class="sd">        automatically by quickly scanning the .bim file.</span>
<span class="sd">    properties: dict, optional</span>
<span class="sd">        A dictionary of any replacement properties. The default is an empty dictionary.</span>
<span class="sd">        The keys of the dictionary are the names of the properties to replace.</span>
<span class="sd">        The possible keys are:</span>

<span class="sd">             &quot;fid&quot; (family id), &quot;iid&quot; (individual or sample id), &quot;father&quot; (father id),</span>
<span class="sd">             &quot;mother&quot; (mother id), &quot;sex&quot;, &quot;pheno&quot; (phenotype), &quot;chromosome&quot;, &quot;sid&quot;</span>
<span class="sd">             (SNP or variant id), &quot;cm_position&quot; (centimorgan position), &quot;bp_position&quot;</span>
<span class="sd">             (base-pair position), &quot;allele_1&quot;, &quot;allele_2&quot;.</span>

<span class="sd">          The values are replacement lists or arrays. A value can also be `None`,</span>
<span class="sd">          meaning do not read or offer this property. See examples, below.</span>

<span class="sd">          The list or array will be converted to a :class:`numpy.ndarray`</span>
<span class="sd">          of the appropriate dtype, if necessary. Any :data:`numpy.nan` values</span>
<span class="sd">          will converted to the appropriate missing value. The PLINK `.fam specification</span>
<span class="sd">          &lt;https://www.cog-genomics.org/plink2/formats#fam&gt;`_</span>
<span class="sd">          and `.bim specification &lt;https://www.cog-genomics.org/plink2/formats#bim&gt;`_</span>
<span class="sd">          lists the dtypes and missing values for each property.</span>

<span class="sd">    count_A1: bool, optional</span>
<span class="sd">        True (default) to count the number of A1 alleles (the PLINK standard).</span>
<span class="sd">        False to count the number of A2 alleles.</span>
<span class="sd">    num_threads: None or int, optional</span>
<span class="sd">        The number of threads with which to read data. Defaults to all available</span>
<span class="sd">        processors.</span>
<span class="sd">        Can also be set with these environment variables (listed in priority order):</span>
<span class="sd">        &#39;PST_NUM_THREADS&#39;, &#39;NUM_THREADS&#39;, &#39;MKL_NUM_THREADS&#39;.</span>
<span class="sd">    skip_format_check: bool, optional</span>
<span class="sd">        False (default) to immediately check for expected starting bytes in</span>
<span class="sd">        the .bed file. True to delay the check until (and if) data is read.</span>
<span class="sd">    fam_location: pathlib.Path or str or URL, optional</span>
<span class="sd">        Path to the file containing information about each individual (sample).</span>
<span class="sd">        Defaults to replacing the .bed file’s suffix with .fam.</span>
<span class="sd">    bim_location: pathlib.Path or str URL, optional</span>
<span class="sd">        Path to the file containing information about each SNP (variant).</span>
<span class="sd">        Defaults to replacing the .bed file’s suffix with .bim.</span>
<span class="sd">    cloud_options: dict, optional</span>
<span class="sd">        A dictionary of options for reading from cloud storage. The default is an empty.</span>
<span class="sd">    max_concurrent_requests: None or int, optional</span>
<span class="sd">        The maximum number of concurrent requests to make to the cloud storage service.</span>
<span class="sd">        Defaults to 10.</span>
<span class="sd">    max_chunk_bytes: None or int, optional</span>
<span class="sd">        The maximum number of bytes to read in a single request to the cloud storage</span>
<span class="sd">        service. Defaults to 8MB.</span>
<span class="sd">    filepath: same as location</span>
<span class="sd">        Deprecated. Use location instead.</span>
<span class="sd">    fam_filepath: same as fam_location</span>
<span class="sd">        Deprecated. Use fam_location instead.</span>
<span class="sd">    bim_filepath: same as bim_location</span>
<span class="sd">        Deprecated. Use bim_location instead.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    open_bed</span>
<span class="sd">        an open_bed object</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Open a local file and list individual (sample) :attr:`iid` and SNP (variant) :attr:`sid`.</span>
<span class="sd">    Then, :meth:`read` the whole file.</span>

<span class="sd">    .. doctest::</span>

<span class="sd">        &gt;&gt;&gt; from bed_reader import open_bed, sample_file</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; file_name = sample_file(&quot;small.bed&quot;)</span>
<span class="sd">        &gt;&gt;&gt; bed = open_bed(file_name)</span>
<span class="sd">        &gt;&gt;&gt; print(bed.iid)</span>
<span class="sd">        [&#39;iid1&#39; &#39;iid2&#39; &#39;iid3&#39;]</span>
<span class="sd">        &gt;&gt;&gt; print(bed.sid)</span>
<span class="sd">        [&#39;sid1&#39; &#39;sid2&#39; &#39;sid3&#39; &#39;sid4&#39;]</span>
<span class="sd">        &gt;&gt;&gt; print(bed.read())</span>
<span class="sd">        [[ 1.  0. nan  0.]</span>
<span class="sd">         [ 2.  0. nan  2.]</span>
<span class="sd">         [ 0.  1.  2.  0.]]</span>
<span class="sd">        &gt;&gt;&gt; del bed  # optional: delete bed object</span>

<span class="sd">    Open a cloud file with a non-default timeout.</span>
<span class="sd">    Then, read the data for one SNP (variant)</span>
<span class="sd">    at index position 2.</span>

<span class="sd">    See :doc:`cloud_urls` for details on reading files from cloud storage.</span>

<span class="sd">    .. doctest::</span>

<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; with open_bed(&quot;https://raw.githubusercontent.com/fastlmm/bed-sample-files/main/small.bed&quot;,</span>
<span class="sd">        ...               cloud_options={&quot;timeout&quot;: &quot;10s&quot;}) as bed:</span>
<span class="sd">        ...     print(bed.read(np.s_[:,2]))</span>
<span class="sd">        [[nan]</span>
<span class="sd">         [nan]</span>
<span class="sd">         [ 2.]]</span>

<span class="sd">    With the local file, replace :attr:`iid`.</span>


<span class="sd">        &gt;&gt;&gt; bed = open_bed(file_name, properties={&quot;iid&quot;:[&quot;sample1&quot;,&quot;sample2&quot;,&quot;sample3&quot;]})</span>
<span class="sd">        &gt;&gt;&gt; print(bed.iid) # replaced</span>
<span class="sd">        [&#39;sample1&#39; &#39;sample2&#39; &#39;sample3&#39;]</span>
<span class="sd">        &gt;&gt;&gt; print(bed.sid) # same as before</span>
<span class="sd">        [&#39;sid1&#39; &#39;sid2&#39; &#39;sid3&#39; &#39;sid4&#39;]</span>

<span class="sd">    Give the number of individuals (samples) and SNPs (variants) so that the .fam and</span>
<span class="sd">    .bim files need never be opened.</span>

<span class="sd">        &gt;&gt;&gt; with open_bed(file_name, iid_count=3, sid_count=4) as bed:</span>
<span class="sd">        ...     print(bed.read())</span>
<span class="sd">        [[ 1.  0. nan  0.]</span>
<span class="sd">         [ 2.  0. nan  2.]</span>
<span class="sd">         [ 0.  1.  2.  0.]]</span>

<span class="sd">    Mark some properties as &quot;don’t read or offer&quot;.</span>

<span class="sd">        &gt;&gt;&gt; bed = open_bed(file_name, properties={</span>
<span class="sd">        ...    &quot;father&quot; : None, &quot;mother&quot; : None, &quot;sex&quot; : None, &quot;pheno&quot; : None,</span>
<span class="sd">        ...    &quot;allele_1&quot; : None, &quot;allele_2&quot;:None })</span>
<span class="sd">        &gt;&gt;&gt; print(bed.iid)        # read from file</span>
<span class="sd">        [&#39;iid1&#39; &#39;iid2&#39; &#39;iid3&#39;]</span>
<span class="sd">        &gt;&gt;&gt; print(bed.allele_2)   # not read and not offered</span>
<span class="sd">        None</span>

<span class="sd">    See the :meth:`read` for details of reading batches via slicing and fancy indexing.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">location</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">,</span> <span class="n">UrlParseResult</span><span class="p">],</span>
        <span class="n">iid_count</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">sid_count</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">properties</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{},</span>
        <span class="n">count_A1</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">num_threads</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">skip_format_check</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">fam_location</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">,</span> <span class="n">UrlParseResult</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">bim_location</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">,</span> <span class="n">UrlParseResult</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">cloud_options</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{},</span>
        <span class="n">max_concurrent_requests</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">max_chunk_bytes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="c1"># accept old keywords</span>
        <span class="n">filepath</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fam_filepath</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">bim_filepath</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">location</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combined</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">filepath</span><span class="p">,</span> <span class="s2">&quot;location&quot;</span><span class="p">,</span> <span class="s2">&quot;filepath&quot;</span><span class="p">)</span>
        <span class="n">fam_location</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combined</span><span class="p">(</span>
            <span class="n">fam_location</span><span class="p">,</span> <span class="n">fam_filepath</span><span class="p">,</span> <span class="s2">&quot;fam_location&quot;</span><span class="p">,</span> <span class="s2">&quot;fam_filepath&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">bim_location</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combined</span><span class="p">(</span>
            <span class="n">bim_location</span><span class="p">,</span> <span class="n">bim_filepath</span><span class="p">,</span> <span class="s2">&quot;bim_location&quot;</span><span class="p">,</span> <span class="s2">&quot;bim_filepath&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">location</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_path_or_url</span><span class="p">(</span><span class="n">location</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cloud_options</span> <span class="o">=</span> <span class="n">cloud_options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count_A1</span> <span class="o">=</span> <span class="n">count_A1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_num_threads</span> <span class="o">=</span> <span class="n">num_threads</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_concurrent_requests</span> <span class="o">=</span> <span class="n">max_concurrent_requests</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_chunk_bytes</span> <span class="o">=</span> <span class="n">max_chunk_bytes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skip_format_check</span> <span class="o">=</span> <span class="n">skip_format_check</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fam_location</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_path_or_url</span><span class="p">(</span><span class="n">fam_location</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">fam_location</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_extension</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">location</span><span class="p">,</span> <span class="s2">&quot;fam&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bim_location</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_path_or_url</span><span class="p">(</span><span class="n">bim_location</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">bim_location</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_replace_extension</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">location</span><span class="p">,</span> <span class="s2">&quot;bim&quot;</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">properties_dict</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_counts</span> <span class="o">=</span> <span class="n">open_bed</span><span class="o">.</span><span class="n">_fix_up_properties</span><span class="p">(</span>
            <span class="n">properties</span><span class="p">,</span> <span class="n">iid_count</span><span class="p">,</span> <span class="n">sid_count</span><span class="p">,</span> <span class="n">use_fill_sequence</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_iid_range</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sid_range</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">skip_format_check</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_url</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">location</span><span class="p">):</span>
                <span class="n">check_file_cloud</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">geturl</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">cloud_options</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">location</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">filepointer</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_file</span><span class="p">(</span><span class="n">filepointer</span><span class="p">)</span>

    <span class="c1"># # its an error to set both location and filepath</span>
    <span class="c1"># location = self._combined(location, filepath, &quot;location&quot;, &quot;filepath&quot;)</span>
    <span class="c1"># fam_location = self._combined(fam_location, fam_filepath, &quot;fam_location&quot;, &quot;fam_filepath&quot;)</span>
    <span class="c1"># bim_location = self._combined(bim_location, bim_filepath, &quot;bim_location&quot;, &quot;bim_filepath&quot;)</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_combined</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">filepath</span><span class="p">,</span> <span class="n">location_name</span><span class="p">,</span> <span class="n">filepath_name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">location</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">filepath</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Cannot set both </span><span class="si">{</span><span class="n">location_name</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">filepath_name</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="c1"># None, None is ok for now</span>
        <span class="k">return</span> <span class="n">location</span> <span class="k">if</span> <span class="n">location</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">filepath</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_replace_extension</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">extension</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">open_bed</span><span class="o">.</span><span class="n">_is_url</span><span class="p">(</span><span class="n">location</span><span class="p">):</span>
            <span class="c1"># Split the path and change the extension</span>
            <span class="n">path</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">location</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
            <span class="n">new_path</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">extension</span><span class="si">}</span><span class="s2">&quot;</span>

            <span class="c1"># Create a new ParseResult with the updated path</span>
            <span class="k">return</span> <span class="n">UrlParseResult</span><span class="p">(</span>
                <span class="n">scheme</span><span class="o">=</span><span class="n">location</span><span class="o">.</span><span class="n">scheme</span><span class="p">,</span>
                <span class="n">netloc</span><span class="o">=</span><span class="n">location</span><span class="o">.</span><span class="n">netloc</span><span class="p">,</span>
                <span class="n">path</span><span class="o">=</span><span class="n">new_path</span><span class="p">,</span>
                <span class="n">params</span><span class="o">=</span><span class="n">location</span><span class="o">.</span><span class="n">params</span><span class="p">,</span>
                <span class="n">query</span><span class="o">=</span><span class="n">location</span><span class="o">.</span><span class="n">query</span><span class="p">,</span>
                <span class="n">fragment</span><span class="o">=</span><span class="n">location</span><span class="o">.</span><span class="n">fragment</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">Path</span><span class="p">)</span>  <span class="c1"># real assert</span>
        <span class="k">return</span> <span class="n">location</span><span class="o">.</span><span class="n">parent</span> <span class="o">/</span> <span class="p">(</span><span class="n">location</span><span class="o">.</span><span class="n">stem</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="n">extension</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_is_url</span><span class="p">(</span><span class="n">location</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">UrlParseResult</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_path_or_url</span><span class="p">(</span><span class="nb">input</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">Path</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">input</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">UrlParseResult</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">input</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="nb">input</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span>
        <span class="p">),</span> <span class="s2">&quot;Expected a string or Path object or UrlParseResult&quot;</span>
        <span class="n">parsed</span> <span class="o">=</span> <span class="n">urlparse</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">parsed</span><span class="o">.</span><span class="n">scheme</span> <span class="ow">and</span> <span class="s2">&quot;://&quot;</span> <span class="ow">in</span> <span class="nb">input</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">parsed</span>
        <span class="k">return</span> <span class="n">Path</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>

<div class="viewcode-block" id="open_bed.read">
<a class="viewcode-back" href="../../index.html#bed_reader.open_bed.read">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">type</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="s2">&quot;float32&quot;</span><span class="p">,</span>
        <span class="n">order</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;F&quot;</span><span class="p">,</span>
        <span class="n">force_python_only</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">num_threads</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">max_concurrent_requests</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">max_chunk_bytes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read genotype information.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index:</span>
<span class="sd">            An optional expression specifying the individuals (samples) and SNPs</span>
<span class="sd">            (variants) to read. (See examples, below).</span>
<span class="sd">            Defaults to ``None``, meaning read all.</span>

<span class="sd">            (If index is a tuple, the first component indexes the individuals and the</span>
<span class="sd">            second indexes</span>
<span class="sd">            the SNPs. If it is not a tuple and not None, it indexes SNPs.)</span>

<span class="sd">        dtype: {&#39;float32&#39; (default), &#39;float64&#39;, &#39;int8&#39;}, optional</span>
<span class="sd">            The desired data-type for the returned array.</span>
<span class="sd">        order : {&#39;F&#39;,&#39;C&#39;}, optional</span>
<span class="sd">            The desired memory layout for the returned array.</span>
<span class="sd">            Defaults to ``F`` (Fortran order, which is SNP-major).</span>
<span class="sd">        force_python_only: bool, optional</span>
<span class="sd">            If False (default), uses the faster Rust code; otherwise it uses the slower</span>
<span class="sd">            pure Python code.</span>

<span class="sd">        num_threads: None or int, optional</span>
<span class="sd">            The number of threads with which to read data. Defaults to all available</span>
<span class="sd">            processors.</span>
<span class="sd">            Can also be set with :class:`open_bed` or these</span>
<span class="sd">            environment variables (listed in priority order):</span>
<span class="sd">            &#39;PST_NUM_THREADS&#39;, &#39;NUM_THREADS&#39;, &#39;MKL_NUM_THREADS&#39;.</span>

<span class="sd">        max_concurrent_requests: None or int, optional</span>
<span class="sd">            The maximum number of concurrent requests to make to the cloud storage</span>
<span class="sd">            service. Defaults to 10.</span>

<span class="sd">        max_chunk_bytes: None or int, optional</span>
<span class="sd">            The maximum number of bytes to read in a single request to the cloud</span>
<span class="sd">            storage service. Defaults to 8MB.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            2-D array containing values of 0, 1, 2, or missing</span>


<span class="sd">        Rows represent individuals (samples). Columns represent SNPs (variants).</span>

<span class="sd">        For ``dtype`` &#39;float32&#39; and &#39;float64&#39;, NaN indicates missing values.</span>
<span class="sd">        For &#39;int8&#39;, -127 indicates missing values.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        To read all data in a .bed file, set ``index`` to ``None``. This is the default.</span>

<span class="sd">        .. doctest::</span>

<span class="sd">            &gt;&gt;&gt; from bed_reader import open_bed, sample_file</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; file_name = sample_file(&quot;small.bed&quot;)</span>
<span class="sd">            &gt;&gt;&gt; with open_bed(file_name) as bed:</span>
<span class="sd">            ...     print(bed.read())</span>
<span class="sd">            [[ 1.  0. nan  0.]</span>
<span class="sd">             [ 2.  0. nan  2.]</span>
<span class="sd">             [ 0.  1.  2.  0.]]</span>

<span class="sd">        To read selected individuals (samples) and/or SNPs (variants), set each part of</span>
<span class="sd">        a :data:`numpy.s_` to an `int`, a list of `int`, a slice expression, or</span>
<span class="sd">        a list of `bool`.</span>
<span class="sd">        Negative integers count from the end of the list.</span>


<span class="sd">        .. doctest::</span>

<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; bed = open_bed(file_name)</span>
<span class="sd">            &gt;&gt;&gt; print(bed.read(np.s_[:,2]))  # read the SNPs indexed by 2.</span>
<span class="sd">            [[nan]</span>
<span class="sd">             [nan]</span>
<span class="sd">             [ 2.]]</span>
<span class="sd">            &gt;&gt;&gt; print(bed.read(np.s_[:,[2,3,0]]))  # read the SNPs indexed by 2, 3, and 0</span>
<span class="sd">            [[nan  0.  1.]</span>
<span class="sd">             [nan  2.  2.]</span>
<span class="sd">             [ 2.  0.  0.]]</span>
<span class="sd">            &gt;&gt;&gt; # read SNPs from 1 (inclusive) to 4 (exclusive)</span>
<span class="sd">            &gt;&gt;&gt; print(bed.read(np.s_[:,1:4]))</span>
<span class="sd">            [[ 0. nan  0.]</span>
<span class="sd">             [ 0. nan  2.]</span>
<span class="sd">             [ 1.  2.  0.]]</span>
<span class="sd">            &gt;&gt;&gt; print(np.unique(bed.chromosome)) # print unique chrom values</span>
<span class="sd">            [&#39;1&#39; &#39;5&#39; &#39;Y&#39;]</span>
<span class="sd">            &gt;&gt;&gt; print(bed.read(np.s_[:,bed.chromosome==&#39;5&#39;])) # read all SNPs in chrom 5</span>
<span class="sd">            [[nan]</span>
<span class="sd">             [nan]</span>
<span class="sd">             [ 2.]]</span>
<span class="sd">            &gt;&gt;&gt; print(bed.read(np.s_[0,:])) # Read 1st individual (across all SNPs)</span>
<span class="sd">            [[ 1.  0. nan  0.]]</span>
<span class="sd">            &gt;&gt;&gt; print(bed.read(np.s_[::2,:])) # Read every 2nd individual</span>
<span class="sd">            [[ 1.  0. nan  0.]</span>
<span class="sd">             [ 0.  1.  2.  0.]]</span>
<span class="sd">            &gt;&gt;&gt; #read last and 2nd-to-last individuals and the last SNPs</span>
<span class="sd">            &gt;&gt;&gt; print(bed.read(np.s_[[-1,-2],-1]))</span>
<span class="sd">            [[0.]</span>
<span class="sd">             [2.]]</span>


<span class="sd">        You can give a dtype for the output.</span>

<span class="sd">        .. doctest::</span>

<span class="sd">            &gt;&gt;&gt; print(bed.read(dtype=&#39;int8&#39;))</span>
<span class="sd">            [[   1    0 -127    0]</span>
<span class="sd">             [   2    0 -127    2]</span>
<span class="sd">             [   0    1    2    0]]</span>
<span class="sd">            &gt;&gt;&gt; del bed  # optional: delete bed object</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">iid_index_or_slice_etc</span><span class="p">,</span> <span class="n">sid_index_or_slice_etc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">order</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;F&quot;</span><span class="p">,</span> <span class="s2">&quot;C&quot;</span><span class="p">}:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;order &#39;</span><span class="si">{</span><span class="n">order</span><span class="si">}</span><span class="s2">&#39; not known, only &#39;F&#39;, &#39;C&#39;&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># Later happy with _iid_range and _sid_range or could it be done with</span>
        <span class="c1"># allocation them?</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iid_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_iid_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iid_count</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;intp&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sid_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sid_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sid_count</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;intp&quot;</span><span class="p">)</span>

        <span class="n">iid_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_iid_range</span><span class="p">[</span><span class="n">iid_index_or_slice_etc</span><span class="p">],</span>
            <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;intp&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">sid_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sid_range</span><span class="p">[</span><span class="n">sid_index_or_slice_etc</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;intp&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">force_python_only</span> <span class="ow">or</span> <span class="n">open_bed</span><span class="o">.</span><span class="n">_is_url</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">location</span><span class="p">):</span>
            <span class="n">num_threads</span> <span class="o">=</span> <span class="n">get_num_threads</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_num_threads</span> <span class="k">if</span> <span class="n">num_threads</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">num_threads</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">max_concurrent_requests</span> <span class="o">=</span> <span class="n">get_max_concurrent_requests</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_max_concurrent_requests</span>
                <span class="k">if</span> <span class="n">max_concurrent_requests</span> <span class="ow">is</span> <span class="kc">None</span>
                <span class="k">else</span> <span class="n">max_concurrent_requests</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">max_chunk_bytes</span> <span class="o">=</span> <span class="n">get_max_chunk_bytes</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_max_chunk_bytes</span> <span class="k">if</span> <span class="n">max_chunk_bytes</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">max_chunk_bytes</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">iid_index</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">sid_index</span><span class="p">)),</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iid_count</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">sid_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">reader</span><span class="p">,</span> <span class="n">location_str</span><span class="p">,</span> <span class="n">is_cloud</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pick_reader</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_cloud</span><span class="p">:</span>
                    <span class="n">reader</span><span class="p">(</span>
                        <span class="n">location_str</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">cloud_options</span><span class="p">,</span>
                        <span class="n">iid_count</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">iid_count</span><span class="p">,</span>
                        <span class="n">sid_count</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sid_count</span><span class="p">,</span>
                        <span class="n">is_a1_counted</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">count_A1</span><span class="p">,</span>
                        <span class="n">iid_index</span><span class="o">=</span><span class="n">iid_index</span><span class="p">,</span>
                        <span class="n">sid_index</span><span class="o">=</span><span class="n">sid_index</span><span class="p">,</span>
                        <span class="n">val</span><span class="o">=</span><span class="n">val</span><span class="p">,</span>
                        <span class="n">num_threads</span><span class="o">=</span><span class="n">num_threads</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">reader</span><span class="p">(</span>
                        <span class="n">location_str</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">cloud_options</span><span class="p">,</span>
                        <span class="n">iid_count</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">iid_count</span><span class="p">,</span>
                        <span class="n">sid_count</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sid_count</span><span class="p">,</span>
                        <span class="n">is_a1_counted</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">count_A1</span><span class="p">,</span>
                        <span class="n">iid_index</span><span class="o">=</span><span class="n">iid_index</span><span class="p">,</span>
                        <span class="n">sid_index</span><span class="o">=</span><span class="n">sid_index</span><span class="p">,</span>
                        <span class="n">val</span><span class="o">=</span><span class="n">val</span><span class="p">,</span>
                        <span class="n">num_threads</span><span class="o">=</span><span class="n">num_threads</span><span class="p">,</span>
                        <span class="n">max_concurrent_requests</span><span class="o">=</span><span class="n">max_concurrent_requests</span><span class="p">,</span>
                        <span class="n">max_chunk_bytes</span><span class="o">=</span><span class="n">max_chunk_bytes</span><span class="p">,</span>
                    <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_A1</span><span class="p">:</span>
                <span class="n">byteZero</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">byteThree</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">byteZero</span> <span class="o">=</span> <span class="mi">2</span>
                <span class="n">byteThree</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">missing</span> <span class="o">=</span> <span class="o">-</span><span class="mi">127</span> <span class="k">if</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="c1"># An earlier version of this code had a way to read consecutive SNPs of code</span>
            <span class="c1"># in one read. May want</span>
            <span class="c1"># to add that ability back to the code.</span>
            <span class="c1"># Also, note that reading with python will often result in</span>
            <span class="c1"># non-contiguous memory</span>
            <span class="c1"># logging.warn(&quot;using pure python plink parser (might be much slower!!)&quot;)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">major</span> <span class="o">==</span> <span class="s2">&quot;SNP&quot;</span><span class="p">:</span>
                <span class="n">minor_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iid_count</span>
                <span class="n">minor_index</span> <span class="o">=</span> <span class="n">iid_index</span>
                <span class="n">major_index</span> <span class="o">=</span> <span class="n">sid_index</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">minor_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sid_count</span>
                <span class="n">minor_index</span> <span class="o">=</span> <span class="n">sid_index</span>
                <span class="n">major_index</span> <span class="o">=</span> <span class="n">iid_index</span>

            <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                <span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mf">0.25</span> <span class="o">*</span> <span class="n">minor_count</span><span class="p">))</span> <span class="o">*</span> <span class="mi">4</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">major_index</span><span class="p">)),</span>
                <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
            <span class="p">)</span>  <span class="c1"># allocate it a little big</span>

            <span class="n">nbyte</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mf">0.25</span> <span class="o">*</span> <span class="n">minor_count</span><span class="p">))</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">location</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">filepointer</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">major_index_value</span><span class="p">,</span> <span class="n">major_index_index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">major_index</span><span class="p">):</span>
                    <span class="n">startbit</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mf">0.25</span> <span class="o">*</span> <span class="n">minor_count</span><span class="p">)</span> <span class="o">*</span> <span class="n">major_index_index</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span>
                    <span class="n">filepointer</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">startbit</span><span class="p">)</span>
                    <span class="nb">bytes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">bytearray</span><span class="p">(</span><span class="n">filepointer</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">nbyte</span><span class="p">)))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                        <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mf">0.25</span> <span class="o">*</span> <span class="n">minor_count</span><span class="p">)),</span> <span class="mi">1</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;F&quot;</span><span class="p">,</span>
                    <span class="p">)</span>

                    <span class="n">val</span><span class="p">[</span><span class="mi">3</span><span class="p">::</span><span class="mi">4</span><span class="p">,</span> <span class="n">major_index_value</span> <span class="p">:</span> <span class="n">major_index_value</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">byteZero</span>
                    <span class="n">val</span><span class="p">[</span><span class="mi">3</span><span class="p">::</span><span class="mi">4</span><span class="p">,</span> <span class="n">major_index_value</span> <span class="p">:</span> <span class="n">major_index_value</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span>
                        <span class="nb">bytes</span> <span class="o">&gt;=</span> <span class="mi">64</span>
                    <span class="p">]</span> <span class="o">=</span> <span class="n">missing</span>
                    <span class="n">val</span><span class="p">[</span><span class="mi">3</span><span class="p">::</span><span class="mi">4</span><span class="p">,</span> <span class="n">major_index_value</span> <span class="p">:</span> <span class="n">major_index_value</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span>
                        <span class="nb">bytes</span> <span class="o">&gt;=</span> <span class="mi">128</span>
                    <span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">val</span><span class="p">[</span><span class="mi">3</span><span class="p">::</span><span class="mi">4</span><span class="p">,</span> <span class="n">major_index_value</span> <span class="p">:</span> <span class="n">major_index_value</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span>
                        <span class="nb">bytes</span> <span class="o">&gt;=</span> <span class="mi">192</span>
                    <span class="p">]</span> <span class="o">=</span> <span class="n">byteThree</span>
                    <span class="nb">bytes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="nb">bytes</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
                    <span class="n">val</span><span class="p">[</span><span class="mi">2</span><span class="p">::</span><span class="mi">4</span><span class="p">,</span> <span class="n">major_index_value</span> <span class="p">:</span> <span class="n">major_index_value</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">byteZero</span>
                    <span class="n">val</span><span class="p">[</span><span class="mi">2</span><span class="p">::</span><span class="mi">4</span><span class="p">,</span> <span class="n">major_index_value</span> <span class="p">:</span> <span class="n">major_index_value</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span>
                        <span class="nb">bytes</span> <span class="o">&gt;=</span> <span class="mi">16</span>
                    <span class="p">]</span> <span class="o">=</span> <span class="n">missing</span>
                    <span class="n">val</span><span class="p">[</span><span class="mi">2</span><span class="p">::</span><span class="mi">4</span><span class="p">,</span> <span class="n">major_index_value</span> <span class="p">:</span> <span class="n">major_index_value</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span>
                        <span class="nb">bytes</span> <span class="o">&gt;=</span> <span class="mi">32</span>
                    <span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">val</span><span class="p">[</span><span class="mi">2</span><span class="p">::</span><span class="mi">4</span><span class="p">,</span> <span class="n">major_index_value</span> <span class="p">:</span> <span class="n">major_index_value</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span>
                        <span class="nb">bytes</span> <span class="o">&gt;=</span> <span class="mi">48</span>
                    <span class="p">]</span> <span class="o">=</span> <span class="n">byteThree</span>
                    <span class="nb">bytes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="nb">bytes</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
                    <span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">4</span><span class="p">,</span> <span class="n">major_index_value</span> <span class="p">:</span> <span class="n">major_index_value</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">byteZero</span>
                    <span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">4</span><span class="p">,</span> <span class="n">major_index_value</span> <span class="p">:</span> <span class="n">major_index_value</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span>
                        <span class="nb">bytes</span> <span class="o">&gt;=</span> <span class="mi">4</span>
                    <span class="p">]</span> <span class="o">=</span> <span class="n">missing</span>
                    <span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">4</span><span class="p">,</span> <span class="n">major_index_value</span> <span class="p">:</span> <span class="n">major_index_value</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="nb">bytes</span> <span class="o">&gt;=</span> <span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">4</span><span class="p">,</span> <span class="n">major_index_value</span> <span class="p">:</span> <span class="n">major_index_value</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span>
                        <span class="nb">bytes</span> <span class="o">&gt;=</span> <span class="mi">12</span>
                    <span class="p">]</span> <span class="o">=</span> <span class="n">byteThree</span>
                    <span class="nb">bytes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="nb">bytes</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
                    <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">4</span><span class="p">,</span> <span class="n">major_index_value</span> <span class="p">:</span> <span class="n">major_index_value</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">byteZero</span>
                    <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">4</span><span class="p">,</span> <span class="n">major_index_value</span> <span class="p">:</span> <span class="n">major_index_value</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span>
                        <span class="nb">bytes</span> <span class="o">&gt;=</span> <span class="mi">1</span>
                    <span class="p">]</span> <span class="o">=</span> <span class="n">missing</span>
                    <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">4</span><span class="p">,</span> <span class="n">major_index_value</span> <span class="p">:</span> <span class="n">major_index_value</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="nb">bytes</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">4</span><span class="p">,</span> <span class="n">major_index_value</span> <span class="p">:</span> <span class="n">major_index_value</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span>
                        <span class="nb">bytes</span> <span class="o">&gt;=</span> <span class="mi">3</span>
                    <span class="p">]</span> <span class="o">=</span> <span class="n">byteThree</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="n">minor_index</span><span class="p">,</span> <span class="p">:]</span>  <span class="c1"># reorder or trim any extra allocation</span>
                <span class="k">assert</span> <span class="n">val</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>  <span class="c1"># real assert</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">open_bed</span><span class="o">.</span><span class="n">_array_properties_are_ok</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
            <span class="c1"># if in force python mode, and individual-major mode, then we need to transpose</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">major</span> <span class="o">==</span> <span class="s2">&quot;individual&quot;</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">T</span>
        <span class="k">return</span> <span class="n">val</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_pick_reader</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">:</span>
            <span class="n">file_reader</span> <span class="o">=</span> <span class="n">read_i8</span>
            <span class="n">cloud_reader</span> <span class="o">=</span> <span class="n">read_cloud_i8</span>
        <span class="k">elif</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">:</span>
            <span class="n">file_reader</span> <span class="o">=</span> <span class="n">read_f64</span>
            <span class="n">cloud_reader</span> <span class="o">=</span> <span class="n">read_cloud_f64</span>
        <span class="k">elif</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">:</span>
            <span class="n">file_reader</span> <span class="o">=</span> <span class="n">read_f32</span>
            <span class="n">cloud_reader</span> <span class="o">=</span> <span class="n">read_cloud_f32</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;dtype &#39;</span><span class="si">{</span><span class="n">dtype</span><span class="si">}</span><span class="s2">&#39; not known, only &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;&#39;int8&#39;, &#39;float32&#39;, and &#39;float64&#39; are allowed.&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">open_bed</span><span class="o">.</span><span class="n">_is_url</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">location</span><span class="p">):</span>
            <span class="n">reader</span> <span class="o">=</span> <span class="n">cloud_reader</span>
            <span class="n">location_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">geturl</span><span class="p">()</span>
            <span class="n">is_cloud</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">reader</span> <span class="o">=</span> <span class="n">file_reader</span>
            <span class="n">location_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">as_posix</span><span class="p">())</span>
            <span class="n">is_cloud</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">reader</span><span class="p">,</span> <span class="n">location_str</span><span class="p">,</span> <span class="n">is_cloud</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">(&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">location</span><span class="si">}</span><span class="s2">&#39;,...)&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">major</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Major mode of a local .bed file.</span>

<span class="sd">        Returns:</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            &#39;SNP&#39; or &#39;individual&#39;</span>


<span class="sd">        Almost all PLINK 1.9 .bed files are &#39;SNP&#39; major. This makes</span>
<span class="sd">        reading the data by SNP(s) fast.</span>

<span class="sd">        Errors</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the file is a cloud file.</span>

<span class="sd">        Example:</span>
<span class="sd">        -------</span>

<span class="sd">        .. doctest::</span>

<span class="sd">            &gt;&gt;&gt; from bed_reader import open_bed, sample_file</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; file_name = sample_file(&quot;small.bed&quot;)</span>
<span class="sd">            &gt;&gt;&gt; with open_bed(file_name) as bed:</span>
<span class="sd">            ...     print(bed.major)</span>
<span class="sd">            SNP</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_url</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">location</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Cannot determine major mode for cloud files&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="c1"># if self._mode is not set, set it</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;mode&quot;</span><span class="p">):</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">location</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">filepointer</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_file</span><span class="p">(</span><span class="n">filepointer</span><span class="p">)</span>

        <span class="k">return</span> <span class="s2">&quot;individual&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">==</span> <span class="sa">b</span><span class="s2">&quot;</span><span class="se">\x00</span><span class="s2">&quot;</span> <span class="k">else</span> <span class="s2">&quot;SNP&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">fid</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Family id of each individual (sample).</span>

<span class="sd">        Returns:</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            array of str</span>


<span class="sd">        &#39;0&#39; represents a missing value.</span>

<span class="sd">        If needed, will cause a one-time read of the .fam file.</span>

<span class="sd">        Example:</span>
<span class="sd">        -------</span>

<span class="sd">        .. doctest::</span>

<span class="sd">            &gt;&gt;&gt; from bed_reader import open_bed, sample_file</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; file_name = sample_file(&quot;small.bed&quot;)</span>
<span class="sd">            &gt;&gt;&gt; with open_bed(file_name) as bed:</span>
<span class="sd">            ...     print(bed.fid)</span>
<span class="sd">            [&#39;fid1&#39; &#39;fid1&#39; &#39;fid2&#39;]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">property_item</span><span class="p">(</span><span class="s2">&quot;fid&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">iid</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Individual id of each individual (sample).</span>

<span class="sd">        Returns:</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            array of str</span>


<span class="sd">        If needed, will cause a one-time read of the .fam file.</span>

<span class="sd">        Example:</span>
<span class="sd">        -------</span>

<span class="sd">        .. doctest::</span>

<span class="sd">            &gt;&gt;&gt; from bed_reader import open_bed, sample_file</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; file_name = sample_file(&quot;small.bed&quot;)</span>
<span class="sd">            &gt;&gt;&gt; with open_bed(file_name) as bed:</span>
<span class="sd">            ...     print(bed.iid)</span>
<span class="sd">            [&#39;iid1&#39; &#39;iid2&#39; &#39;iid3&#39;]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">property_item</span><span class="p">(</span><span class="s2">&quot;iid&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">father</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Father id of each individual (sample).</span>

<span class="sd">        Returns:</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            array of str</span>


<span class="sd">        &#39;0&#39; represents a missing value.</span>

<span class="sd">        If needed, will cause a one-time read of the .fam file.</span>

<span class="sd">        Example:</span>
<span class="sd">        -------</span>

<span class="sd">        .. doctest::</span>

<span class="sd">            &gt;&gt;&gt; from bed_reader import open_bed, sample_file</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; file_name = sample_file(&quot;small.bed&quot;)</span>
<span class="sd">            &gt;&gt;&gt; with open_bed(file_name) as bed:</span>
<span class="sd">            ...     print(bed.father)</span>
<span class="sd">            [&#39;iid23&#39; &#39;iid23&#39; &#39;iid22&#39;]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">property_item</span><span class="p">(</span><span class="s2">&quot;father&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">mother</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mother id of each individual (sample).</span>

<span class="sd">        Returns:</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            array of str</span>


<span class="sd">        &#39;0&#39; represents a missing value.</span>

<span class="sd">        If needed, will cause a one-time read of the .fam file.</span>

<span class="sd">        Example:</span>
<span class="sd">        -------</span>

<span class="sd">        .. doctest::</span>

<span class="sd">            &gt;&gt;&gt; from bed_reader import open_bed, sample_file</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; file_name = sample_file(&quot;small.bed&quot;)</span>
<span class="sd">            &gt;&gt;&gt; with open_bed(file_name) as bed:</span>
<span class="sd">            ...     print(bed.mother)</span>
<span class="sd">            [&#39;iid34&#39; &#39;iid34&#39; &#39;iid33&#39;]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">property_item</span><span class="p">(</span><span class="s2">&quot;mother&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sex</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sex of each individual (sample).</span>

<span class="sd">        Returns:</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            array of 0, 1, or 2</span>


<span class="sd">        0 is unknown, 1 is male, 2 is female</span>

<span class="sd">        If needed, will cause a one-time read of the .fam file.</span>

<span class="sd">        Example:</span>
<span class="sd">        -------</span>
<span class="sd">        .. doctest::</span>

<span class="sd">            &gt;&gt;&gt; from bed_reader import open_bed, sample_file</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; file_name = sample_file(&quot;small.bed&quot;)</span>
<span class="sd">            &gt;&gt;&gt; with open_bed(file_name) as bed:</span>
<span class="sd">            ...     print(bed.sex)</span>
<span class="sd">            [1 2 0]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">property_item</span><span class="p">(</span><span class="s2">&quot;sex&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">pheno</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A phenotype for each individual (sample)</span>
<span class="sd">        (seldom used).</span>

<span class="sd">        Returns:</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            array of str</span>


<span class="sd">        &#39;0&#39; may represent a missing value.</span>

<span class="sd">        If needed, will cause a one-time read of the .fam file.</span>

<span class="sd">        Example:</span>
<span class="sd">        -------</span>

<span class="sd">        .. doctest::</span>

<span class="sd">            &gt;&gt;&gt; from bed_reader import open_bed, sample_file</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; file_name = sample_file(&quot;small.bed&quot;)</span>
<span class="sd">            &gt;&gt;&gt; with open_bed(file_name) as bed:</span>
<span class="sd">            ...     print(bed.pheno)</span>
<span class="sd">            [&#39;red&#39; &#39;red&#39; &#39;blue&#39;]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">property_item</span><span class="p">(</span><span class="s2">&quot;pheno&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">properties</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;All the properties returned as a dictionary.</span>

<span class="sd">        Returns:</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            all the properties</span>


<span class="sd">        The keys of the dictionary are the names of the properties, namely:</span>

<span class="sd">             &quot;fid&quot; (family id), &quot;iid&quot; (individual or sample id), &quot;father&quot; (father id),</span>
<span class="sd">             &quot;mother&quot; (mother id), &quot;sex&quot;, &quot;pheno&quot; (phenotype), &quot;chromosome&quot;, &quot;sid&quot;</span>
<span class="sd">             (SNP or variant id), &quot;cm_position&quot; (centimorgan position), &quot;bp_position&quot;</span>
<span class="sd">             (base-pair position), &quot;allele_1&quot;, &quot;allele_2&quot;.</span>

<span class="sd">        The values are :class:`numpy.ndarray`.</span>

<span class="sd">        If needed, will cause a one-time read of the .fam and .bim file.</span>

<span class="sd">        Example:</span>
<span class="sd">        -------</span>

<span class="sd">        .. doctest::</span>

<span class="sd">            &gt;&gt;&gt; from bed_reader import open_bed, sample_file</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; file_name = sample_file(&quot;small.bed&quot;)</span>
<span class="sd">            &gt;&gt;&gt; with open_bed(file_name) as bed:</span>
<span class="sd">            ...     print(len(bed.properties)) #length of dict</span>
<span class="sd">            12</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">_meta_meta</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">property_item</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties_dict</span>

<div class="viewcode-block" id="open_bed.property_item">
<a class="viewcode-back" href="../../index.html#bed_reader.open_bed.property_item">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">property_item</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieve one property by name.</span>

<span class="sd">        Returns:</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            a property value</span>


<span class="sd">        The name is one of these:</span>

<span class="sd">             &quot;fid&quot; (family id), &quot;iid&quot; (individual or sample id), &quot;father&quot; (father id),</span>
<span class="sd">             &quot;mother&quot; (mother id), &quot;sex&quot;, &quot;pheno&quot; (phenotype), &quot;chromosome&quot;, &quot;sid&quot;</span>
<span class="sd">             (SNP or variant id), &quot;cm_position&quot; (centimorgan position), &quot;bp_position&quot;</span>
<span class="sd">             (base-pair position), &quot;allele_1&quot;, &quot;allele_2&quot;.</span>

<span class="sd">        If needed, will cause a one-time read of the .fam or .bim file.</span>

<span class="sd">        Example:</span>
<span class="sd">        -------</span>

<span class="sd">        .. doctest::</span>

<span class="sd">            &gt;&gt;&gt; from bed_reader import open_bed, sample_file</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; file_name = sample_file(&quot;small.bed&quot;)</span>
<span class="sd">            &gt;&gt;&gt; with open_bed(file_name) as bed:</span>
<span class="sd">            ...     print(bed.property_item(&#39;chromosome&#39;))</span>
<span class="sd">            [&#39;1&#39; &#39;1&#39; &#39;5&#39; &#39;Y&#39;]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties_dict</span><span class="p">:</span>
            <span class="n">mm</span> <span class="o">=</span> <span class="n">_meta_meta</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_read_fam_or_bim</span><span class="p">(</span><span class="n">suffix</span><span class="o">=</span><span class="n">mm</span><span class="o">.</span><span class="n">suffix</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties_dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">chromosome</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Chromosome of each SNP (variant).</span>

<span class="sd">        Returns:</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            array of str</span>


<span class="sd">        &#39;0&#39; represents a missing value.</span>

<span class="sd">        If needed, will cause a one-time read of the .bim file.</span>

<span class="sd">        Example:</span>
<span class="sd">        -------</span>

<span class="sd">        .. doctest::</span>

<span class="sd">            &gt;&gt;&gt; from bed_reader import open_bed, sample_file</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; file_name = sample_file(&quot;small.bed&quot;)</span>
<span class="sd">            &gt;&gt;&gt; with open_bed(file_name) as bed:</span>
<span class="sd">            ...     print(bed.chromosome)</span>
<span class="sd">            [&#39;1&#39; &#39;1&#39; &#39;5&#39; &#39;Y&#39;]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">property_item</span><span class="p">(</span><span class="s2">&quot;chromosome&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sid</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;SNP id of each SNP (variant).</span>

<span class="sd">        Returns:</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            array of str</span>


<span class="sd">        If needed, will cause a one-time read of the .bim file.</span>

<span class="sd">        Example:</span>
<span class="sd">        -------</span>

<span class="sd">        .. doctest::</span>

<span class="sd">            &gt;&gt;&gt; from bed_reader import open_bed, sample_file</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; file_name = sample_file(&quot;small.bed&quot;)</span>
<span class="sd">            &gt;&gt;&gt; with open_bed(file_name) as bed:</span>
<span class="sd">            ...     print(bed.sid)</span>
<span class="sd">            [&#39;sid1&#39; &#39;sid2&#39; &#39;sid3&#39; &#39;sid4&#39;]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">property_item</span><span class="p">(</span><span class="s2">&quot;sid&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">cm_position</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Centimorgan position of each SNP (variant).</span>

<span class="sd">        Returns:</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            array of float</span>


<span class="sd">        0.0 represents a missing value.</span>

<span class="sd">        If needed, will cause a one-time read of the .bim file.</span>

<span class="sd">        Example:</span>
<span class="sd">        -------</span>

<span class="sd">        .. doctest::</span>

<span class="sd">            &gt;&gt;&gt; from bed_reader import open_bed, sample_file</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; file_name = sample_file(&quot;small.bed&quot;)</span>
<span class="sd">            &gt;&gt;&gt; with open_bed(file_name) as bed:</span>
<span class="sd">            ...     print(bed.cm_position)</span>
<span class="sd">            [ 100.4 2000.5 4000.7 7000.9]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">property_item</span><span class="p">(</span><span class="s2">&quot;cm_position&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">bp_position</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Base-pair position of each SNP (variant).</span>

<span class="sd">        Returns:</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            array of int</span>


<span class="sd">        0 represents a missing value.</span>

<span class="sd">        If needed, will cause a one-time read of the .bim file.</span>

<span class="sd">        Example:</span>
<span class="sd">        -------</span>

<span class="sd">        .. doctest::</span>

<span class="sd">            &gt;&gt;&gt; from bed_reader import open_bed, sample_file</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; file_name = sample_file(&quot;small.bed&quot;)</span>
<span class="sd">            &gt;&gt;&gt; with open_bed(file_name) as bed:</span>
<span class="sd">            ...     print(bed.bp_position)</span>
<span class="sd">            [   1  100 1000 1004]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">property_item</span><span class="p">(</span><span class="s2">&quot;bp_position&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">allele_1</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;First allele of each SNP (variant).</span>

<span class="sd">        Returns:</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            array of str</span>


<span class="sd">        If needed, will cause a one-time read of the .bim file.</span>

<span class="sd">        Example:</span>
<span class="sd">        -------</span>

<span class="sd">        .. doctest::</span>

<span class="sd">            &gt;&gt;&gt; from bed_reader import open_bed, sample_file</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; file_name = sample_file(&quot;small.bed&quot;)</span>
<span class="sd">            &gt;&gt;&gt; with open_bed(file_name) as bed:</span>
<span class="sd">            ...     print(bed.allele_1)</span>
<span class="sd">            [&#39;A&#39; &#39;T&#39; &#39;A&#39; &#39;T&#39;]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">property_item</span><span class="p">(</span><span class="s2">&quot;allele_1&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">allele_2</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Second allele of each SNP (variant),.</span>

<span class="sd">        Returns:</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            array of str</span>


<span class="sd">        If needed, will cause a one-time read of the .bim file.</span>

<span class="sd">        Example:</span>
<span class="sd">        -------</span>

<span class="sd">        .. doctest::</span>

<span class="sd">            &gt;&gt;&gt; from bed_reader import open_bed, sample_file</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; file_name = sample_file(&quot;small.bed&quot;)</span>
<span class="sd">            &gt;&gt;&gt; with open_bed(file_name) as bed:</span>
<span class="sd">            ...     print(bed.allele_2)</span>
<span class="sd">            [&#39;A&#39; &#39;C&#39; &#39;C&#39; &#39;G&#39;]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">property_item</span><span class="p">(</span><span class="s2">&quot;allele_2&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">iid_count</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of individuals (samples).</span>

<span class="sd">        Returns:</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            number of individuals</span>


<span class="sd">        If needed, will cause a fast line-count of the .fam file.</span>

<span class="sd">        Example:</span>
<span class="sd">        -------</span>

<span class="sd">        .. doctest::</span>

<span class="sd">            &gt;&gt;&gt; from bed_reader import open_bed, sample_file</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; file_name = sample_file(&quot;small.bed&quot;)</span>
<span class="sd">            &gt;&gt;&gt; with open_bed(file_name) as bed:</span>
<span class="sd">            ...     print(bed.iid_count)</span>
<span class="sd">            3</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_count</span><span class="p">(</span><span class="s2">&quot;fam&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sid_count</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of SNPs (variants).</span>

<span class="sd">        Returns:</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            number of SNPs</span>


<span class="sd">        If needed, will cause a fast line-count of the .bim file.</span>

<span class="sd">        Example:</span>
<span class="sd">        -------</span>

<span class="sd">        .. doctest::</span>

<span class="sd">            &gt;&gt;&gt; from bed_reader import open_bed, sample_file</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; file_name = sample_file(&quot;small.bed&quot;)</span>
<span class="sd">            &gt;&gt;&gt; with open_bed(file_name) as bed:</span>
<span class="sd">            ...     print(bed.sid_count)</span>
<span class="sd">            4</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_count</span><span class="p">(</span><span class="s2">&quot;bim&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_property_location</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">suffix</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">suffix</span> <span class="o">==</span> <span class="s2">&quot;fam&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fam_location</span>
        <span class="k">assert</span> <span class="n">suffix</span> <span class="o">==</span> <span class="s2">&quot;bim&quot;</span>  <span class="c1"># real assert</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bim_location</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">suffix</span><span class="p">):</span>
        <span class="n">count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_counts</span><span class="p">[</span><span class="n">suffix</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">count</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">location</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_property_location</span><span class="p">(</span><span class="n">suffix</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">open_bed</span><span class="o">.</span><span class="n">_is_url</span><span class="p">(</span><span class="n">location</span><span class="p">):</span>
                <span class="c1"># should not download twice from cloud</span>
                <span class="k">if</span> <span class="n">suffix</span> <span class="o">==</span> <span class="s2">&quot;fam&quot;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">property_item</span><span class="p">(</span><span class="s2">&quot;iid&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="c1"># ... unless user doesn&#39;t want iid</span>
                        <span class="n">file_bytes</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span>
                            <span class="n">url_to_bytes</span><span class="p">(</span><span class="n">location</span><span class="o">.</span><span class="n">geturl</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">cloud_options</span><span class="p">),</span>
                        <span class="p">)</span>
                        <span class="n">count</span> <span class="o">=</span> <span class="n">_rawincount</span><span class="p">(</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">file_bytes</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iid</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">suffix</span> <span class="o">==</span> <span class="s2">&quot;bim&quot;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">property_item</span><span class="p">(</span><span class="s2">&quot;sid&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="c1"># ... unless user doesn&#39;t want sid</span>
                        <span class="n">file_bytes</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span>
                            <span class="n">url_to_bytes</span><span class="p">(</span><span class="n">location</span><span class="o">.</span><span class="n">geturl</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">cloud_options</span><span class="p">),</span>
                        <span class="p">)</span>
                        <span class="n">count</span> <span class="o">=</span> <span class="n">_rawincount</span><span class="p">(</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">file_bytes</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sid</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;real assert&quot;</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                    <span class="n">count</span> <span class="o">=</span> <span class="n">_rawincount</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_counts</span><span class="p">[</span><span class="n">suffix</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span>
        <span class="k">return</span> <span class="n">count</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_check_file</span><span class="p">(</span><span class="n">filepointer</span><span class="p">):</span>
        <span class="n">magic_number</span> <span class="o">=</span> <span class="n">filepointer</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">magic_number</span> <span class="o">!=</span> <span class="sa">b</span><span class="s2">&quot;l</span><span class="se">\x1b</span><span class="s2">&quot;</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Not a valid .bed file&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="n">filepointer</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Check if mode is either individual-major or SNP-major</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="se">\x00</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;</span><span class="se">\x01</span><span class="s2">&quot;</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Not a valid .bed file&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mode</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="fm">__exit__</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_array_properties_are_ok</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="s2">&quot;F&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">val</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">&quot;F_CONTIGUOUS&quot;</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">order</span> <span class="o">==</span> <span class="s2">&quot;C&quot;</span>  <span class="c1"># real assert</span>
        <span class="k">return</span> <span class="n">val</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s2">&quot;C_CONTIGUOUS&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of individuals (samples) and SNPs (variants).</span>

<span class="sd">        Returns:</span>
<span class="sd">        -------</span>
<span class="sd">        (int, int)</span>
<span class="sd">            number of individuals, number of SNPs</span>


<span class="sd">        If needed, will cause a fast line-count of the .fam and .bim files.</span>

<span class="sd">        Example:</span>
<span class="sd">        -------</span>

<span class="sd">        .. doctest::</span>

<span class="sd">            &gt;&gt;&gt; from bed_reader import open_bed, sample_file</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; file_name = sample_file(&quot;small.bed&quot;)</span>
<span class="sd">            &gt;&gt;&gt; with open_bed(file_name) as bed:</span>
<span class="sd">            ...     print(bed.shape)</span>
<span class="sd">            (3, 4)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iid_count</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sid_count</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_split_index</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
        <span class="n">iid_index</span> <span class="o">=</span> <span class="n">open_bed</span><span class="o">.</span><span class="n">_fix_up_index</span><span class="p">(</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">sid_index</span> <span class="o">=</span> <span class="n">open_bed</span><span class="o">.</span><span class="n">_fix_up_index</span><span class="p">(</span><span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">iid_index</span><span class="p">,</span> <span class="n">sid_index</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_fix_up_index</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># make a shortcut for None</span>
            <span class="k">return</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>  <span class="c1"># If index is an int, return it in an array</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="fm">__index__</span><span class="p">()</span>  <span class="c1"># (see</span>
            <span class="c1"># https://stackoverflow.com/questions/3501382/checking-whether-a-variable-is-an-integer-or-not)</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">return</span> <span class="n">index</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_write_fam_or_bim</span><span class="p">(</span><span class="n">base_filepath</span><span class="p">,</span> <span class="n">properties</span><span class="p">,</span> <span class="n">suffix</span><span class="p">,</span> <span class="n">property_filepath</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">suffix</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;fam&quot;</span><span class="p">,</span> <span class="s2">&quot;bim&quot;</span><span class="p">},</span> <span class="s2">&quot;real assert&quot;</span>

        <span class="n">filepath</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">Path</span><span class="p">(</span><span class="n">property_filepath</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">property_filepath</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="n">base_filepath</span><span class="o">.</span><span class="n">parent</span> <span class="o">/</span> <span class="p">(</span><span class="n">base_filepath</span><span class="o">.</span><span class="n">stem</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="n">suffix</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">fam_bim_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">mm</span> <span class="ow">in</span> <span class="n">_meta_meta</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">mm</span><span class="o">.</span><span class="n">suffix</span> <span class="o">==</span> <span class="n">suffix</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">fam_bim_list</span><span class="p">)</span> <span class="o">==</span> <span class="n">mm</span><span class="o">.</span><span class="n">column</span><span class="p">,</span> <span class="s2">&quot;real assert&quot;</span>
                <span class="n">fam_bim_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">properties</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

        <span class="n">sep</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span> <span class="k">if</span> <span class="n">suffix</span> <span class="o">==</span> <span class="s2">&quot;fam&quot;</span> <span class="k">else</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">filepointer</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fam_bim_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
                <span class="n">filepointer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                    <span class="n">sep</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="n">index</span><span class="p">])</span> <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="n">fam_bim_list</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_fix_up_properties_array</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">missing_value</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">input</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">open_bed</span><span class="o">.</span><span class="n">_fix_up_properties_array</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">input</span><span class="p">),</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">missing_value</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> should be one dimensional&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="n">do_missing_values</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="nb">input</span><span class="p">[</span><span class="nb">input</span> <span class="o">!=</span> <span class="nb">input</span><span class="p">]</span> <span class="o">=</span> <span class="n">missing_value</span>
            <span class="n">old_settings</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s2">&quot;warn&quot;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="o">**</span><span class="n">old_settings</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
            <span class="c1"># This will convert, for example, numerical sids to string sids or</span>
            <span class="c1"># floats that happen to be integers into ints,</span>
            <span class="c1"># but there will be a warning generated.</span>
            <span class="n">old_settings</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s2">&quot;warn&quot;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="o">**</span><span class="n">old_settings</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="nb">input</span>

        <span class="c1"># Change NaN in input to correct missing value</span>
        <span class="k">if</span> <span class="n">do_missing_values</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">):</span>
            <span class="n">output</span><span class="p">[</span><span class="nb">input</span> <span class="o">!=</span> <span class="nb">input</span><span class="p">]</span> <span class="o">=</span> <span class="n">missing_value</span>

        <span class="k">return</span> <span class="n">output</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_fix_up_properties</span><span class="p">(</span><span class="n">properties</span><span class="p">,</span> <span class="n">iid_count</span><span class="p">,</span> <span class="n">sid_count</span><span class="p">,</span> <span class="n">use_fill_sequence</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">properties</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_meta_meta</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;properties key &#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&#39; not known&quot;</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="n">count_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;fam&quot;</span><span class="p">:</span> <span class="n">iid_count</span><span class="p">,</span> <span class="s2">&quot;bim&quot;</span><span class="p">:</span> <span class="n">sid_count</span><span class="p">}</span>
        <span class="n">properties_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">mm</span> <span class="ow">in</span> <span class="n">_meta_meta</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">count</span> <span class="o">=</span> <span class="n">count_dict</span><span class="p">[</span><span class="n">mm</span><span class="o">.</span><span class="n">suffix</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">properties</span> <span class="ow">or</span> <span class="p">(</span><span class="n">use_fill_sequence</span> <span class="ow">and</span> <span class="n">properties</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">use_fill_sequence</span><span class="p">:</span>
                    <span class="n">output</span> <span class="o">=</span> <span class="n">mm</span><span class="o">.</span><span class="n">fill_sequence</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">mm</span><span class="o">.</span><span class="n">missing_value</span><span class="p">,</span> <span class="n">mm</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">continue</span>  <span class="c1"># Test coverage reaches this, but doesn&#39;t report it.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">output</span> <span class="o">=</span> <span class="n">open_bed</span><span class="o">.</span><span class="n">_fix_up_properties_array</span><span class="p">(</span>
                    <span class="n">properties</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">mm</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">mm</span><span class="o">.</span><span class="n">missing_value</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">output</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">count</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">count_dict</span><span class="p">[</span><span class="n">mm</span><span class="o">.</span><span class="n">suffix</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">count</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">output</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;The length of override </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">output</span><span class="p">)</span><span class="si">}</span><span class="s2">, should not &quot;</span>
                        <span class="o">+</span> <span class="s2">&quot;be different from the current &quot;</span>
                        <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">_count_name</span><span class="p">[</span><span class="n">mm</span><span class="o">.</span><span class="n">suffix</span><span class="p">]</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">count</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="p">)</span>
            <span class="n">properties_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">output</span>
        <span class="k">return</span> <span class="n">properties_dict</span><span class="p">,</span> <span class="n">count_dict</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_read_fam_or_bim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">suffix</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">property_location</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_property_location</span><span class="p">(</span><span class="n">suffix</span><span class="p">)</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loading </span><span class="si">{</span><span class="n">suffix</span><span class="si">}</span><span class="s2"> file </span><span class="si">{</span><span class="n">property_location</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_counts</span><span class="p">[</span><span class="n">suffix</span><span class="p">]</span>

        <span class="n">delimiter</span> <span class="o">=</span> <span class="n">_delimiters</span><span class="p">[</span><span class="n">suffix</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">delimiter</span> <span class="ow">in</span> <span class="p">{</span><span class="sa">r</span><span class="s2">&quot;\s+&quot;</span><span class="p">}:</span>
            <span class="n">delimiter</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">usecolsdict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">dtype_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">mm</span> <span class="ow">in</span> <span class="n">_meta_meta</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">mm</span><span class="o">.</span><span class="n">suffix</span> <span class="ow">is</span> <span class="n">suffix</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties_dict</span><span class="p">:</span>
                <span class="n">usecolsdict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">mm</span><span class="o">.</span><span class="n">column</span>
                <span class="n">dtype_dict</span><span class="p">[</span><span class="n">mm</span><span class="o">.</span><span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="n">mm</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">assert</span> <span class="nb">list</span><span class="p">(</span><span class="n">usecolsdict</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">==</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">usecolsdict</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>  <span class="c1"># real assert</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">usecolsdict</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>  <span class="c1"># real assert</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_url</span><span class="p">(</span><span class="n">property_location</span><span class="p">):</span>
            <span class="n">file_bytes</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span>
                <span class="n">url_to_bytes</span><span class="p">(</span><span class="n">property_location</span><span class="o">.</span><span class="n">geturl</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">cloud_options</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">file_bytes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">columns</span><span class="p">,</span> <span class="n">row_count</span> <span class="o">=</span> <span class="p">[],</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># note similar code below</span>
                <span class="n">columns</span><span class="p">,</span> <span class="n">row_count</span> <span class="o">=</span> <span class="n">_read_csv</span><span class="p">(</span>
                    <span class="n">BytesIO</span><span class="p">(</span><span class="n">file_bytes</span><span class="p">),</span>
                    <span class="n">delimiter</span><span class="o">=</span><span class="n">delimiter</span><span class="p">,</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="n">dtype_dict</span><span class="p">,</span>
                    <span class="n">usecols</span><span class="o">=</span><span class="n">usecolsdict</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getsize</span><span class="p">(</span><span class="n">property_location</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">columns</span><span class="p">,</span> <span class="n">row_count</span> <span class="o">=</span> <span class="p">[],</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">columns</span><span class="p">,</span> <span class="n">row_count</span> <span class="o">=</span> <span class="n">_read_csv</span><span class="p">(</span>
                <span class="n">property_location</span><span class="p">,</span>
                <span class="n">delimiter</span><span class="o">=</span><span class="n">delimiter</span><span class="p">,</span>
                <span class="n">dtype</span><span class="o">=</span><span class="n">dtype_dict</span><span class="p">,</span>
                <span class="n">usecols</span><span class="o">=</span><span class="n">usecolsdict</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">count</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_counts</span><span class="p">[</span><span class="n">suffix</span><span class="p">]</span> <span class="o">=</span> <span class="n">row_count</span>
        <span class="k">elif</span> <span class="n">count</span> <span class="o">!=</span> <span class="n">row_count</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The number of lines in the *.</span><span class="si">{</span><span class="n">suffix</span><span class="si">}</span><span class="s2"> file, </span><span class="si">{</span><span class="n">row_count</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;should not be different from the current &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;f</span><span class="si">{_count_name[suffix]}</span><span class="s2">, </span><span class="si">{count}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">usecolsdict</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">mm</span> <span class="o">=</span> <span class="n">_meta_meta</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">row_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">mm</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">output</span> <span class="o">=</span> <span class="n">columns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">mm</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
                    <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">mm</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">properties_dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">output</span>

<div class="viewcode-block" id="open_bed.read_sparse">
<a class="viewcode-back" href="../../index.html#bed_reader.open_bed.read_sparse">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_sparse</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">index</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">type</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="s2">&quot;float32&quot;</span><span class="p">,</span>
        <span class="n">batch_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="nb">format</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;csc&quot;</span><span class="p">,</span>
        <span class="n">num_threads</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">max_concurrent_requests</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">max_chunk_bytes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">Union</span><span class="p">[</span><span class="n">sparse</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">,</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">])</span> <span class="k">if</span> <span class="n">sparse</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># type: ignore</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read genotype information into a :mod:`scipy.sparse` matrix. Sparse matrices</span>
<span class="sd">        may be useful when the data is mostly zeros.</span>

<span class="sd">        .. note::</span>
<span class="sd">            This method requires :mod:`scipy`. Install `scipy` with:</span>

<span class="sd">            .. code-block:: bash</span>

<span class="sd">                pip install --upgrade bed-reader[sparse]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index:</span>
<span class="sd">            An optional expression specifying the individuals (samples) and SNPs</span>
<span class="sd">            (variants) to read. (See examples, below).</span>
<span class="sd">            Defaults to ``None``, meaning read all.</span>

<span class="sd">            (If index is a tuple, the first component indexes the individuals and the</span>
<span class="sd">            second indexes</span>
<span class="sd">            the SNPs. If it is not a tuple and not None, it indexes SNPs.)</span>

<span class="sd">        dtype: {&#39;float32&#39; (default), &#39;float64&#39;, &#39;int8&#39;}, optional</span>
<span class="sd">            The desired data-type for the returned array.</span>
<span class="sd">        batch_size: None or int, optional</span>
<span class="sd">            Number of dense columns or rows to read at a time, internally.</span>
<span class="sd">            Defaults to round(sqrt(total-number-of-columns-or-rows-to-read)).</span>
<span class="sd">        format : {&#39;csc&#39;,&#39;csr&#39;}, optional</span>
<span class="sd">            The desired format of the sparse matrix.</span>
<span class="sd">            Defaults to ``csc`` (Compressed Sparse Column, which is SNP-major).</span>
<span class="sd">        num_threads: None or int, optional</span>
<span class="sd">            The number of threads with which to read data. Defaults to all available</span>
<span class="sd">            processors.</span>
<span class="sd">            Can also be set with :class:`open_bed` or these</span>
<span class="sd">            environment variables (listed in priority order):</span>
<span class="sd">            &#39;PST_NUM_THREADS&#39;, &#39;NUM_THREADS&#39;, &#39;MKL_NUM_THREADS&#39;.</span>
<span class="sd">        max_concurrent_requests: None or int, optional</span>
<span class="sd">            The maximum number of concurrent requests to make to the cloud storage</span>
<span class="sd">            service. Defaults to 10.</span>
<span class="sd">        max_chunk_bytes: None or int, optional</span>
<span class="sd">            The maximum number of bytes to read in a single request to the cloud</span>
<span class="sd">            storage service. Defaults to 8MB.</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        a :class:`scipy.sparse.csc_matrix` (default) or :class:`scipy.sparse.csr_matrix`</span>

<span class="sd">        Rows represent individuals (samples). Columns represent SNPs (variants).</span>

<span class="sd">        For ``dtype`` &#39;float32&#39; and &#39;float64&#39;, NaN indicates missing values.</span>
<span class="sd">        For &#39;int8&#39;, -127 indicates missing values.</span>


<span class="sd">        The memory used by the final sparse matrix is approximately:</span>

<span class="sd">           # of non-zero values * (4 bytes + 1 byte (for int8))</span>

<span class="sd">        For example, consider reading 1000 individuals (samples) x 50,000 SNPs (variants)</span>
<span class="sd">        into csc format where the data is 97% sparse.</span>
<span class="sd">        The memory used will be about 7.5 MB (1000 x 50,000 x 3% x 5 bytes).</span>
<span class="sd">        This is 15% of the 50 MB needed by a dense matrix.</span>

<span class="sd">        Internally, the function reads the data via small dense matrices.</span>
<span class="sd">        For this example, by default, the function will read 1000 individuals x 224 SNPs</span>
<span class="sd">        (because 224 * 224 is about 50,000).</span>
<span class="sd">        The memory used by the small dense matrix is 1000 x 244 x 1 byte (for int8) = 0.224 MB.</span>

<span class="sd">        You can set `batch_size`. Larger values will be faster.</span>
<span class="sd">        Smaller values will use less memory.</span>

<span class="sd">        For this example, we might want to set the `batch_size` to 5000. Then,</span>
<span class="sd">        the memory used by the small dense matrix</span>
<span class="sd">        would be 1000 x 5000 x 1 byte (for int8) = 5 MB,</span>
<span class="sd">        similar to the 7.5 MB needed for the final sparse matrix.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Read all data in a .bed file into a :class:`scipy.sparse.csc_matrix`.</span>
<span class="sd">        The file has 10 individuals (samples) by 20 SNPs (variants).</span>
<span class="sd">        All but eight values are 0.</span>

<span class="sd">        .. doctest::</span>

<span class="sd">            &gt;&gt;&gt; # pip install bed-reader[samples,sparse]  # if needed</span>
<span class="sd">            &gt;&gt;&gt; from bed_reader import open_bed, sample_file</span>
<span class="sd">            &gt;&gt;&gt;</span>
<span class="sd">            &gt;&gt;&gt; file_name = sample_file(&quot;sparse.bed&quot;)</span>
<span class="sd">            &gt;&gt;&gt; with open_bed(file_name) as bed:</span>
<span class="sd">            ...     print(bed.shape) # doctest:+NORMALIZE_WHITESPACE +ELLIPSIS</span>
<span class="sd">            ...     val_sparse = bed.read_sparse(dtype=&quot;int8&quot;)</span>
<span class="sd">            (10, 20)</span>
<span class="sd">            &gt;&gt;&gt; print(&quot;Nonzero Values&quot;, val_sparse.data) # doctest:+NORMALIZE_WHITESPACE +ELLIPSIS</span>
<span class="sd">            Nonzero Values [1 2 2 1 1 1 1 1]</span>

<span class="sd">        To read selected individuals (samples) and/or SNPs (variants), set each part of</span>
<span class="sd">        a :data:`numpy.s_` to an `int`, a list of `int`, a slice expression, or</span>
<span class="sd">        a list of `bool`.</span>
<span class="sd">        Negative integers count from the end of the list.</span>

<span class="sd">        .. doctest::</span>

<span class="sd">            &gt;&gt;&gt; import numpy as np</span>
<span class="sd">            &gt;&gt;&gt; bed = open_bed(file_name)</span>
<span class="sd">            &gt;&gt;&gt; print(&quot;Nonzero Values&quot;, bed.read_sparse(np.s_[:,5], dtype=&quot;int8&quot;).data)  # read the SNPs indexed by 5.</span>
<span class="sd">            Nonzero Values [2]</span>
<span class="sd">            &gt;&gt;&gt; # read the SNPs indexed by 5, 4, and 0</span>
<span class="sd">            &gt;&gt;&gt; print(&quot;Nonzero Values&quot;, bed.read_sparse(np.s_[:,[5,4,0]], dtype=&quot;int8&quot;).data)</span>
<span class="sd">            Nonzero Values [2 1]</span>
<span class="sd">            &gt;&gt;&gt; # read SNPs from 1 (inclusive) to 11 (exclusive)</span>
<span class="sd">            &gt;&gt;&gt; print(&quot;Nonzero Values&quot;, bed.read_sparse(np.s_[:,1:11], dtype=&quot;int8&quot;).data)</span>
<span class="sd">            Nonzero Values [1 2 2 1 1]</span>
<span class="sd">            &gt;&gt;&gt; print(np.unique(bed.chromosome)) # print unique chrom values</span>
<span class="sd">            [&#39;1&#39; &#39;5&#39; &#39;Y&#39;]</span>
<span class="sd">            &gt;&gt;&gt; # read all SNPs in chrom 5</span>
<span class="sd">            &gt;&gt;&gt; print(&quot;Nonzero Values&quot;, bed.read_sparse(np.s_[:,bed.chromosome==&#39;5&#39;], dtype=&quot;int8&quot;).data)</span>
<span class="sd">            Nonzero Values [1 2 2 1 1 1 1 1]</span>
<span class="sd">            &gt;&gt;&gt; # Read 1st individual (across all SNPs)</span>
<span class="sd">            &gt;&gt;&gt; print(&quot;Nonzero Values&quot;, bed.read_sparse(np.s_[0,:], dtype=&quot;int8&quot;).data)</span>
<span class="sd">            Nonzero Values [2]</span>
<span class="sd">            &gt;&gt;&gt; print(&quot;Nonzero Values&quot;, bed.read_sparse(np.s_[::2,:], dtype=&quot;int8&quot;).data) # Read every 2nd individual</span>
<span class="sd">            Nonzero Values [1 2 2 1 1]</span>
<span class="sd">            &gt;&gt;&gt; # read last and 2nd-to-last individuals and the 15th-from-the-last SNP</span>
<span class="sd">            &gt;&gt;&gt; print(&quot;Nonzero Values&quot;, bed.read_sparse(np.s_[[-1,-2],-15], dtype=&quot;int8&quot;).data)</span>
<span class="sd">            Nonzero Values [2]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sparse</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span>
                <span class="s2">&quot;The function read_sparse() requires scipy. &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;Install it with &#39;pip install --upgrade bed-reader[sparse]&#39;.&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">iid_index_or_slice_etc</span><span class="p">,</span> <span class="n">sid_index_or_slice_etc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Similar code in read().</span>
        <span class="c1"># Later happy with _iid_range and _sid_range or could it be done with</span>
        <span class="c1"># allocation them?</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iid_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_iid_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iid_count</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;intp&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sid_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sid_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sid_count</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;intp&quot;</span><span class="p">)</span>

        <span class="n">iid_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_iid_range</span><span class="p">[</span><span class="n">iid_index_or_slice_etc</span><span class="p">],</span>
            <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;intp&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">sid_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sid_range</span><span class="p">[</span><span class="n">sid_index_or_slice_etc</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;intp&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">iid_index</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span><span class="o">.</span><span class="n">max</span>
            <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">sid_index</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span><span class="o">.</span><span class="n">max</span>
        <span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;Too many Individuals or SNPs (variants) requested. &quot;</span>
                <span class="s2">&quot;Maximum is {np.iinfo(np.int32).max}.&quot;</span>
            <span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="n">msg</span><span class="p">,</span>
            <span class="p">)</span>


        <span class="k">if</span> <span class="n">batch_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">batch_size</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sid_index</span><span class="p">)))</span>

        <span class="n">num_threads</span> <span class="o">=</span> <span class="n">get_num_threads</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_num_threads</span> <span class="k">if</span> <span class="n">num_threads</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">num_threads</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">max_concurrent_requests</span> <span class="o">=</span> <span class="n">get_max_concurrent_requests</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_max_concurrent_requests</span>
            <span class="k">if</span> <span class="n">max_concurrent_requests</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="n">max_concurrent_requests</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">max_chunk_bytes</span> <span class="o">=</span> <span class="n">get_max_chunk_bytes</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_max_chunk_bytes</span> <span class="k">if</span> <span class="n">max_chunk_bytes</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">max_chunk_bytes</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="nb">format</span> <span class="o">==</span> <span class="s2">&quot;csc&quot;</span><span class="p">:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;F&quot;</span>
            <span class="n">indptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sid_index</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">format</span> <span class="o">==</span> <span class="s2">&quot;csr&quot;</span><span class="p">:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="s2">&quot;C&quot;</span>
            <span class="n">indptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">iid_index</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;format &#39;</span><span class="si">{</span><span class="nb">format</span><span class="si">}</span><span class="s2">&#39; not known. Expected &#39;csc&#39; or &#39;csr&#39;.&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># We init data and indices with zero element arrays to set their dtype.</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)]</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iid_count</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">sid_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">reader</span><span class="p">,</span> <span class="n">location_str</span><span class="p">,</span> <span class="n">is_cloud</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pick_reader</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">format</span> <span class="o">==</span> <span class="s2">&quot;csc&quot;</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">iid_index</span><span class="p">),</span> <span class="n">batch_size</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">batch_start</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sid_index</span><span class="p">),</span> <span class="n">batch_size</span><span class="p">):</span>
                    <span class="n">batch_end</span> <span class="o">=</span> <span class="n">batch_start</span> <span class="o">+</span> <span class="n">batch_size</span>
                    <span class="k">if</span> <span class="n">batch_end</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">sid_index</span><span class="p">):</span>
                        <span class="n">batch_end</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sid_index</span><span class="p">)</span>
                        <span class="k">del</span> <span class="n">val</span>
                        <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                            <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">iid_index</span><span class="p">),</span> <span class="n">batch_end</span> <span class="o">-</span> <span class="n">batch_start</span><span class="p">),</span>
                            <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>
                            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="n">batch_slice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">batch_start</span><span class="p">:</span><span class="n">batch_end</span><span class="p">]</span>
                    <span class="n">batch_index</span> <span class="o">=</span> <span class="n">sid_index</span><span class="p">[</span><span class="n">batch_slice</span><span class="p">]</span>

                    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_cloud</span><span class="p">:</span>
                        <span class="n">reader</span><span class="p">(</span>
                            <span class="n">location_str</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">cloud_options</span><span class="p">,</span>
                            <span class="n">iid_count</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">iid_count</span><span class="p">,</span>
                            <span class="n">sid_count</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sid_count</span><span class="p">,</span>
                            <span class="n">is_a1_counted</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">count_A1</span><span class="p">,</span>
                            <span class="n">iid_index</span><span class="o">=</span><span class="n">iid_index</span><span class="p">,</span>
                            <span class="n">sid_index</span><span class="o">=</span><span class="n">batch_index</span><span class="p">,</span>
                            <span class="n">val</span><span class="o">=</span><span class="n">val</span><span class="p">,</span>
                            <span class="n">num_threads</span><span class="o">=</span><span class="n">num_threads</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">reader</span><span class="p">(</span>
                            <span class="n">location_str</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">cloud_options</span><span class="p">,</span>
                            <span class="n">iid_count</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">iid_count</span><span class="p">,</span>
                            <span class="n">sid_count</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sid_count</span><span class="p">,</span>
                            <span class="n">is_a1_counted</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">count_A1</span><span class="p">,</span>
                            <span class="n">iid_index</span><span class="o">=</span><span class="n">iid_index</span><span class="p">,</span>
                            <span class="n">sid_index</span><span class="o">=</span><span class="n">batch_index</span><span class="p">,</span>
                            <span class="n">val</span><span class="o">=</span><span class="n">val</span><span class="p">,</span>
                            <span class="n">num_threads</span><span class="o">=</span><span class="n">num_threads</span><span class="p">,</span>
                            <span class="n">max_concurrent_requests</span><span class="o">=</span><span class="n">max_concurrent_requests</span><span class="p">,</span>
                            <span class="n">max_chunk_bytes</span><span class="o">=</span><span class="n">max_chunk_bytes</span><span class="p">,</span>
                        <span class="p">)</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">sparsify</span><span class="p">(</span>
                        <span class="n">val</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">iid_index</span><span class="p">,</span> <span class="n">batch_slice</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">indptr</span><span class="p">,</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">format</span> <span class="o">==</span> <span class="s2">&quot;csr&quot;</span>  <span class="c1"># real assert</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">batch_size</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sid_index</span><span class="p">)),</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">batch_start</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">iid_index</span><span class="p">),</span> <span class="n">batch_size</span><span class="p">):</span>
                    <span class="n">batch_end</span> <span class="o">=</span> <span class="n">batch_start</span> <span class="o">+</span> <span class="n">batch_size</span>
                    <span class="k">if</span> <span class="n">batch_end</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">iid_index</span><span class="p">):</span>
                        <span class="n">batch_end</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">iid_index</span><span class="p">)</span>
                        <span class="k">del</span> <span class="n">val</span>
                        <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                            <span class="p">(</span><span class="n">batch_end</span> <span class="o">-</span> <span class="n">batch_start</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sid_index</span><span class="p">)),</span>
                            <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>
                            <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
                        <span class="p">)</span>

                    <span class="n">batch_slice</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="n">batch_start</span><span class="p">:</span><span class="n">batch_end</span><span class="p">]</span>
                    <span class="n">batch_index</span> <span class="o">=</span> <span class="n">iid_index</span><span class="p">[</span><span class="n">batch_slice</span><span class="p">]</span>

                    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_cloud</span><span class="p">:</span>
                        <span class="n">reader</span><span class="p">(</span>
                            <span class="n">location_str</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">cloud_options</span><span class="p">,</span>
                            <span class="n">iid_count</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">iid_count</span><span class="p">,</span>
                            <span class="n">sid_count</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sid_count</span><span class="p">,</span>
                            <span class="n">is_a1_counted</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">count_A1</span><span class="p">,</span>
                            <span class="n">iid_index</span><span class="o">=</span><span class="n">batch_index</span><span class="p">,</span>
                            <span class="n">sid_index</span><span class="o">=</span><span class="n">sid_index</span><span class="p">,</span>
                            <span class="n">val</span><span class="o">=</span><span class="n">val</span><span class="p">,</span>
                            <span class="n">num_threads</span><span class="o">=</span><span class="n">num_threads</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">reader</span><span class="p">(</span>
                            <span class="n">location_str</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">cloud_options</span><span class="p">,</span>
                            <span class="n">iid_count</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">iid_count</span><span class="p">,</span>
                            <span class="n">sid_count</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sid_count</span><span class="p">,</span>
                            <span class="n">is_a1_counted</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">count_A1</span><span class="p">,</span>
                            <span class="n">iid_index</span><span class="o">=</span><span class="n">batch_index</span><span class="p">,</span>
                            <span class="n">sid_index</span><span class="o">=</span><span class="n">sid_index</span><span class="p">,</span>
                            <span class="n">val</span><span class="o">=</span><span class="n">val</span><span class="p">,</span>
                            <span class="n">num_threads</span><span class="o">=</span><span class="n">num_threads</span><span class="p">,</span>
                            <span class="n">max_concurrent_requests</span><span class="o">=</span><span class="n">max_concurrent_requests</span><span class="p">,</span>
                            <span class="n">max_chunk_bytes</span><span class="o">=</span><span class="n">max_chunk_bytes</span><span class="p">,</span>
                        <span class="p">)</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">sparsify</span><span class="p">(</span>
                        <span class="n">val</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">sid_index</span><span class="p">,</span> <span class="n">batch_slice</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">indptr</span><span class="p">,</span>
                    <span class="p">)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">format</span> <span class="o">==</span> <span class="s2">&quot;csc&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">(</span>
                <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">indptr</span><span class="p">),</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">iid_index</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">sid_index</span><span class="p">)),</span>
            <span class="p">)</span>
        <span class="k">assert</span> <span class="nb">format</span> <span class="o">==</span> <span class="s2">&quot;csr&quot;</span>  <span class="c1"># real assert</span>
        <span class="k">return</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span>
            <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">indptr</span><span class="p">),</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">iid_index</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">sid_index</span><span class="p">)),</span>
        <span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">sparsify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">minor_index</span><span class="p">,</span> <span class="n">batch_slice</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">indptr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">flatten</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
        <span class="n">nz_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">flatten</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">column_indexes</span> <span class="o">=</span> <span class="n">nz_indices</span> <span class="o">//</span> <span class="nb">len</span><span class="p">(</span><span class="n">minor_index</span><span class="p">)</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span>
            <span class="n">column_indexes</span><span class="p">,</span> <span class="n">minlength</span><span class="o">=</span><span class="n">batch_slice</span><span class="o">.</span><span class="n">stop</span> <span class="o">-</span> <span class="n">batch_slice</span><span class="o">.</span><span class="n">start</span><span class="p">,</span>
        <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">counts_with_initial</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span>
            <span class="n">indptr</span><span class="p">[</span><span class="n">batch_slice</span><span class="o">.</span><span class="n">start</span> <span class="p">:</span> <span class="n">batch_slice</span><span class="o">.</span><span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">counts</span><span class="p">,</span>
        <span class="p">]</span>

        <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flatten</span><span class="p">[</span><span class="n">nz_indices</span><span class="p">])</span>
        <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">nz_indices</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">minor_index</span><span class="p">)))</span>
        <span class="n">indptr</span><span class="p">[</span><span class="mi">1</span><span class="p">:][</span><span class="n">batch_slice</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">counts_with_initial</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_read_csv</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">usecols</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">pattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^np\.\w+\((.+?)\)$&quot;</span><span class="p">)</span>

    <span class="c1"># Prepare the usecols by ensuring it is a list of indices</span>
    <span class="n">usecols_indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">usecols</span><span class="p">)</span>
    <span class="n">transposed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span>
        <span class="n">filepath</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">str_</span><span class="p">,</span>
        <span class="n">delimiter</span><span class="o">=</span><span class="n">delimiter</span><span class="p">,</span>
        <span class="n">usecols</span><span class="o">=</span><span class="n">usecols_indices</span><span class="p">,</span>
        <span class="n">unpack</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">transposed</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">transposed</span> <span class="o">=</span> <span class="n">transposed</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">row_count</span> <span class="o">=</span> <span class="n">transposed</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># because unpack=True</span>

    <span class="c1"># Convert column lists to numpy arrays with the specified dtype</span>
    <span class="n">columns</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">output_index</span><span class="p">,</span> <span class="n">input_index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">usecols_indices</span><span class="p">):</span>
        <span class="n">col</span> <span class="o">=</span> <span class="n">transposed</span><span class="p">[</span><span class="n">output_index</span><span class="p">]</span>

        <span class="c1"># work around numpy/python bug</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">pattern</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="n">col</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">pattern</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">col</span><span class="p">])</span>

        <span class="c1"># Find the dtype for this column</span>
        <span class="n">col_dtype</span> <span class="o">=</span> <span class="n">dtype</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">input_index</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">str_</span><span class="p">)</span>
        <span class="c1"># Convert the column list to a numpy array with the specified dtype</span>
        <span class="n">columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_convert_to_dtype</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">col_dtype</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">columns</span><span class="p">,</span> <span class="n">row_count</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_convert_to_dtype</span><span class="p">(</span><span class="n">str_arr</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
    <span class="k">assert</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">str_</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">]</span>  <span class="c1"># real assert</span>

    <span class="k">if</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">str_</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">str_arr</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">new_arr</span> <span class="o">=</span> <span class="n">str_arr</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">:</span>
            <span class="k">raise</span>
        <span class="c1"># for backwards compatibility, see if intermediate float helps int conversion</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span>  <span class="c1"># real assert</span>
            <span class="n">float_arr</span> <span class="o">=</span> <span class="n">str_arr</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">e</span>
        <span class="n">new_arr</span> <span class="o">=</span> <span class="n">float_arr</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">new_arr</span><span class="p">,</span> <span class="n">float_arr</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;invalid literal for int: &#39;</span><span class="si">{</span><span class="n">str_arr</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">new_arr</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">float_arr</span><span class="p">)][:</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;)&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="n">msg</span><span class="p">,</span>
            <span class="p">)</span>
    <span class="k">return</span> <span class="n">new_arr</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">pytest</span>

    <span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>

    <span class="n">pytest</span><span class="o">.</span><span class="n">main</span><span class="p">([</span><span class="s2">&quot;--doctest-modules&quot;</span><span class="p">,</span> <span class="vm">__file__</span><span class="p">])</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Carl Kadie.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>